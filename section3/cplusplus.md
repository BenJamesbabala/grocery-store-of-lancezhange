# C++

- 指针
    - 指针数组： 每个元素都是指针 char *p[10];
    - 数组指针： 指向数组的指针 int (*p)[10]; 对二维数组，可以用数组指针指向一行，然后 p++ 就指向下一行（注意数组指针的步长为列数），数组指针因此也被称为行指针
    - 声明一个类的指针数组时，并不会调用该类的构造函数
- STL string
    - 构造 string a("this is a string");
    - size(), empty()
- string stream
    - istringstream
    - ostringstream
    - string化： .str()
    - 
- 友元
    - 友元函数本身不是类的成员函数
- 多态
    - 函数重载和模板属于编译时多态
    - 如果不是虚函数，则用子类初始化的基类指针调用的是基类的，对析构函数也是如此，因此，为了使子类正常析构，子类的析构函数通常被声明为虚函数。
- 联合体
    - 联合体的占用空间取其包含元素的最大占用空间

- 对齐
    - `#pragma pack(4)`
- 枚举
    - 枚举类型占用4个字节
- 柔性数组
    - 例如    
           struct A{
              Int a;
              char data[0]; // 必须是结构体的最后一个元素
           };
    - 柔性数组其实只是一个标识占位符，并不占结构体的空间


## static 关键字
static 关键字的作用：隐藏，持久化，初始化为0

- 静态全局变量
    - 作用域仅限于当前源文件，且只初始化一次
- 静态局部变量
- 静态函数
    - 普通函数在每次被调用时均有一份拷贝，而静态函数在内存中只拷贝一份，因此比较节约内存
    - 静态函数只在声明它的源文件中可见，因此其他文件中可以定义相同名字的函数，不会发生冲突

## 输入输出流
- stdio.h 与 cstdio 的区别：前者是C的标准库，后者是C++中对前者的封装；其他如 stdlib.h 与 cstdlib 同理。

## 内联函数
内联函数在编译期间被编译器将其代码所有调用该函数的地方

有些编译器即使不加 `inline` 关键字，也可能会对短小的函数做内联优化

### 模板元编程



## 魔鬼在细节之中
- 赋值表达式的返回值即所赋值本身

### 并行编程
[gitbook: C++ 并发编程](https://www.gitbook.com/book/chenxiaowei/cpp_concurrency_in_action/details)

### 参考资料
[Awesome Cpp](https://github.com/fffaraz/awesome-cpp)
